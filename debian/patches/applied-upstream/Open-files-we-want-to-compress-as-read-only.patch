From: Raphael Manfredi <Raphael_Manfredi@pobox.com>
Date: Tue, 26 Jan 2021 08:49:18 +0100
Applied-Upstream: https://github.com/logrotate/logrotate/commit/a111ef2b4ea50f143e7566328f50bae565d2418f
Subject: Open files we want to compress as read-only.

It is not required to be able to open the logfile in read-write mode
when we are compressing the file.  A read-only open is sufficient.

This is useful when trying to run logrotate as non-root, to handle
rotation of files created by a container for instance.  As long as we
have write permission in the directory holding the logfile, there is no
reason to prevent the operation (since that user could manually rename()
the file with write permissions in the directory and then compress it).

Closes: https://github.com/logrotate/logrotate/pull/372
---
 logrotate.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/logrotate.c b/logrotate.c
index 507c85a..0a778bf 100644
--- a/logrotate.c
+++ b/logrotate.c
@@ -770,6 +770,8 @@ static int compressLogFile(const char *name, const struct logInfo *log, const st
     int error_printed = 0;
     char *prevCtx;
     pid_t pid;
+    int in_flags;
+    const char *in_how;
 
     message(MESS_DEBUG, "compressing log with: %s\n", log->compress_prog);
     if (debug)
@@ -785,8 +787,18 @@ static int compressLogFile(const char *name, const struct logInfo *log, const st
     compressedName = alloca(strlen(name) + strlen(log->compress_ext) + 2);
     sprintf(compressedName, "%s%s", name, log->compress_ext);
 
-    if ((inFile = open(name, O_RDWR | O_NOFOLLOW)) < 0) {
-        message(MESS_ERROR, "unable to open %s for compression: %s\n", name, strerror(errno));
+    in_flags = O_NOFOLLOW;
+    if (log->flags & LOG_FLAG_SHRED) {
+        /* need write access for shredding */
+        in_flags |= O_RDWR;
+        in_how = "read-write";
+    } else {
+        in_flags |= O_RDONLY;
+        in_how = "read-only";
+    }
+    if ((inFile = open(name, in_flags)) < 0) {
+        message(MESS_ERROR, "unable to open %s (%s) for compression: %s\n",
+            name, in_how, strerror(errno));
         return 1;
     }
 
